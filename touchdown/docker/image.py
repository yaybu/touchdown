# Copyright 2014 Isotoma Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This code was originally built for Fuselage and has been adapted to to run in
# Docker

import json
import tarfile

import six

from fuselage.builder import build

from touchdown.core import action, argument, plan, resource

try:
    import docker
except ImportError:
    docker = None


class Image(resource.Resource):

    name = 'docker_image'

    source_image = argument.String(default='ubuntu')
    tag = argument.String()
    environment = argument.Dict()
    volumes = argument.List()
    ports = argument.List()
    cmd = argument.String()
    maintainer = argument.String()


class BuildAction(action.Action):

    def run(self):
        tar_buffer = six.BytesIO()
        tar = tarfile.open(mode='w:gz', fileobj=tar_buffer)

        def add(name, buf, mode=0o644):
            ti = tarfile.TarInfo(name=name)
            ti.size = len(buf.buf)
            ti.mode = mode
            tar.addfile(tarinfo=ti, fileobj=buf)

        add('payload.pex', build(self.bundle), mode=0o755)
        add('Dockerfile', six.BytesIO(self.get_dockerfile()))

        tar.close()
        tar_buffer.seek(0)

        build_output_stream = self.plan.client.build(
            fileobj=tar_buffer,
            custom_context=True,
            stream=True,
            rm=True,
            tag=self.tag,
        )

        for line in self.plan.format_output_stream(build_output_stream):
            self.plan.echo(line)


class Apply(plan.Plan):

    resource = Image

    def get_dockerfile(self):
        df = [
            '# This Dockerfile was automatically generated by fuselage',
        ]

        if self.maintainer:
            df.append('MAINTAINER %s' % self.maintainer)

        df.append('FROM %s' % self.from_image or 'ubuntu')
        df.append('')

        for k, v in self.env.items():
            df.append('ENV %s %s' % (k, v))

        if self.volumes:
            df.append('VOLUME %s' % json.dumps(self.volumes))

        if self.ports:
            df.append('EXPOSE %s' % ' '.join(str(p) for p in self.ports))

        if self.env or self.volumes or self.ports:
            df.append('')

        df.extend([
            'RUN if [ -f /usr/bin/apt-get ]; then apt-get update && apt-get install python -y; fi',
            'RUN if [ -f /usr/bin/yum ]; then yum install python -y; fi',
            '',
            'ADD payload.pex /payload.pex',
            'RUN /payload.pex',
            'RUN rm /payload.pex',
        ])

        if self.cmd:
            df.append('')
            df.append('CMD %s' % json.dumps(self.cmd))

        return '\n'.join(df)

    def format_output_stream(self, stream):
        status = None
        for data in stream:
            data = json.loads(data)
            if 'status' in data:
                if status != data['status']:
                    if status:
                        yield '\n'
                    status = data['status']
                    yield status
                else:
                    yield '.'
            else:
                if status:
                    yield '\n'
                    status = None

                if 'stream' in data:
                    yield data['stream']
                elif 'errorDetail' in data:
                    raise RuntimeError(data['errorDetail']['message'])

    def get_actions(self):
        self.client = docker.Client(
            base_url='unix://var/run/docker.sock',
            version='auto',
            timeout=10,
        )

        # FIXME: Handle errors here and report if unable to connect to docker instance?
        self.client.version()

        yield BuildAction(self)
